{"/pages/2022-02-04-cv.html": {
    "title": "CV Guillem Fernandez",
    "keywords": "Personal",
    "url": "/pages/2022-02-04-cv.html",
    "body": "Download it Engineering Director I define myself as a People Engineer. I’ve been involved in IT Engineering since I left College. I’ve founded two companies, helped create two more from zero to success, and been involved in many other initiatives. I am teaching at University of Barcelona because I love to share my experience. In general I love challenges. Work Experience Engineering Manager - 2020 - Present BUMBLE / Barcelona, Spain Being part of the Friendship business line in Bumble, I am in charge of a team of engineers coming from different backgrounds. The goal in this position has been to create high performance and cohered teams, built on the concept of independence, good practices and commitment with the project. CEO &amp; Cofounder - 2019 - 2022 CoKaiDo / Barcelona, Spain I founded this company in 2019. My role as CEO in this project was to drive the business to become the most successful company in expert and high-level training and help our clients to get ownership of the expertise and best practices. I created CoKaiDo as the central source of improvement for companies that wanted to go one step forward and build high performance teams. Managing Director - 2016 - 2019 Codurance / Barcelona, Spain As a Managing Director I am responsible of running Barcelona Codurance’s office, taking care of business operations and provide consultancy and training services to our clients. Our daily work is based in helping our customer to acquire the necessary skill to be able to work applying engineering best practices. Previous experiences Senior Lead Developer - PaddyPower 2015 - 2016 Senior Lead Developer - Stella&amp;Dot 2013 - 2015 Senior iOS Developer - Freelance 2012 - 2013 Mobile Team Lead - HostelWorld 2012 - 2012 Senior iOS Developer - ISIS Papyrus 2011 - 2012 CTO &amp; HR Manager - Arestes 2009 - 2011 Business Manager - Alten TIC 2008 - 2009 See details and more at LinkedIn"
  },"/pages/2022-02-05-contact.html": {
    "title": "Contact me",
    "keywords": "Jekyll",
    "url": "/pages/2022-02-05-contact.html",
    "body": ""
  },"/opinion/2016-09-18-what-is-the-tatus-of-bdd-in-swift.html": {
    "title": "What Is the Status of BDD in Swift",
    "keywords": "Opinion",
    "url": "/opinion/2016-09-18-what-is-the-tatus-of-bdd-in-swift.html",
    "body": "Again woking on a project with a heavy load on BDD. In this case we had a greenfield project in front of us, as nothing done regarding automation was usable here. Obviously my advice was to opt for a Calabash based solution as I believe it’s a great, ‘standardised’ and long term solution. Calabash is a cucumber based solution that works pretty well with iOS. Of corse you find some problems, the main one is that is an intrusive solution based on the inclusion of an http server. That server allows the communication between the cucumber Gem and the iOS app, to access to the UI elements and perform the different actions on it. That brings the problem of being dependent on the system. With Swift calabash still works, but with the new UI Testing framework a new solution appears. Up to now I didn’t dive into the nitty-gritties of the tool and to do it, there is no better way than creating an app. It’s going to be a simple app that will only allow you to make some voice records on your iPhone, I could call it YAMVR, but probably I will go for something more glamourous. So stay tunned and send any comment you have if you want me to check something special or add any feature to the app. Thanks for reading me and don’t forget to follow me on twitter and check my repos in github."
  },"/opinion/2016-09-16-and-now-what.html": {
    "title": "And Now What?",
    "keywords": "Opinion",
    "url": "/opinion/2016-09-16-and-now-what.html",
    "body": "Once again I am there in that situation, you know, finishing the current contract and thinking about what’s coming next. This usually happens once a year or six months, depending on the contract, but this time I’ve been working for the same company for almost two years. To be fair I need some fresh air, but at the same time I’m pretty tired having to look for a new project. First things first, I started by updating my CV, my website, doing some housekeeping on my github repos and starting to post some new things to make some advertising. As usual I’ve started by reviewing the typical web sites and applying for those job offers I believe could be interesting, sending emails to the agencies I’ve worked for before and telling my friends and colleagues that I am ‘open to new opportunities’. But then the worse part of all this situation comes in. I started receiving every day up to five emails from agencies. Most of them didn’t even take five minutes to read my profile or the email I sent them, which I took my time to write hoping it would help on filtering what I was going to receive, but no, that was not the case. Of those that matched my profile, casually or by reading it, many of them are urgent and almost all have these things in common: It’s going to be the next social media cracking app. An amazing project with young and dynamic people. Working with the most advanced technologies. The next generation app. Some of them contained very different font types between paragraphs, which clearly means a copy and paste from a previous email or document. Even a couple of them were for a different person or at least my name was not in the email but another one’s was. Also most of them were looking for permanent positions, and that’s something I’d like to avoid if possible, I love to work as freelance. They all looked like a factory with no interest in the quality of the product or the offer. With a few good exceptions which I keep in my records, the rest are not of my interest or at least aren’t what I need to have the future I want to have. At this point I realised that something was going really bad. That was not the way and there should be better, different way to find the next project. After some enquiries, a friend of mine told me about Toptal App engineer community. He told me that it’s a company that does it differently. I took some time to make my investigations and they seem to be the answer. The first thing they do different is the kind of questions they ask to start applying. No silly and unrelated questions, no filling questions with no sense, just the right questions. That form is destined to be the starting point for an interview, not to opt to a position but to opt to be part of the team, the pool of engineers. That seems to be a new way of doing things and ensuring only the best engineers are part of it. I don’t know how this new adventure is going to end, but I promise you to write a following post telling you what happened and what the experience has been for me.*"
  },"/development/tips'n'tricks/2015-01-23-mfmailcomposeviewcontroller-nightmare.html": {
    "title": "MFMailComposeViewController Nightmare",
    "keywords": "Development Tips'n'Tricks",
    "url": "/development/tips'n'tricks/2015-01-23-mfmailcomposeviewcontroller-nightmare.html",
    "body": "I’ve just gone through MFMailComposeViewController because I had a problem with the look&amp;feel of the Cancel and Save buttons on the mail compose dialog toolbar. They just looked too, how to say, transparent. The problem was that in the app I am working on I use appearance proxy. That seemed not to work with MFMailComposeViewController. My first approach was to change those behavior that didn’t fit in my needs. And the result was … nothing. It’s like that doesn’t apply to it if you are using a global setting. You can find many solutions thought the internet telling you to user setTintColor on the MFMailComposeViewController object you’ve just created, and they will work if you don’t use the appearance proxy at some point of your app initialization like: [[UIBarButtonItem appearanceWhenContainedIn:[UINavigationBar class], nil] setTitleTextAttributes:buttonAttributes forState:UIControlStateNormal]; [[UINavigationBar appearance] setTintColor:[UIColor redColor]]; If you did it, forget about using: [mailViewController.navigationBar setTintColor:[UIColor redColor]]; [self presentViewController:mailViewController animated:YES completion:nil]; The result is going to be the same nothing I had. But the good new is that there is a solution. I know it’s not the most elegant one but it works and you can save a lot of time investigating that I already invested. The solution is to change the global setting in the appearance proxy to match what you need and set it back to the original behavior when the dialog is dismissed. As you know there is not going to be any dialog with navigation bar while the mail composer is present, it is safe to change it. To revert the changes, you need to do it in - (void)mailComposeController:(MFMailComposeViewController*)controller didFinishWithResult:(MFMailComposeResult)result error:(NSError*)error. I use a singleton to contain the configuration colors I need to restore the original look&amp;feel, if you don’t have it, you need to implement a mechanism to do it or you’ll have a coupled and dependent code. Thanks for reading and don’t forget to share and follow me in twitter @guillemfg."
  },"/development/tips'n'tricks/2015-01-20-ios-7-and-ios-8-living-together.html": {
    "title": "iOS 7 and iOS 8 living together",
    "keywords": "Development Tips'n'Tricks",
    "url": "/development/tips'n'tricks/2015-01-20-ios-7-and-ios-8-living-together.html",
    "body": "This is the first post of 2015. I want to start it with a new category, Tips and Tricks. I’ve found that in my daily work I am fixing many different small pieces of code that, in some cases, will be interesting for you, so I decided to share it in my blog. The firs one is how to include code that behaves differently when it’s running on iOS 7 than when it’s running on iOS 8, for example. I’ve found two main different ways to do it. Check the responsiveness to a selector. Most of the times, the problem comes because of a change in the signature of an API or the deprecation of the methods. In this case the easiest way is to check if the object responds to the given selector. Two examples are NSOperation and UIApplication. NSOperation *myOperation = [[NSOperation alloc] init]; if ([myOperation respondsToSelector:@selector(setName)]) { // iOS 8 specific code } else { // iOS 7 speficic code } UIApplication *app = [UIApplication sharedApplication]; if ([app respondsToSelector:@selector(registerForRemoteNotifications)]) { // iOS 8 specific code } else { // iOS 7 speficic code } Check the value of NSFundationVersionNumber The second option is using NSFundationVersionNumber. This option gives you the flexibility to behave differently not because of any restriction, but because functional requirements or just because you like it. if(floor(NSFoundationVersionNumber) &lt;= NSFoundationVersionNumber_iOS_7_0){ // iOS 7.0 specific code }else if(floor(NSFoundationVersionNumber) &lt;= NSFoundationVersionNumber_iOS_7_1) { // iOS 7.1 specific code } else { // iOS 8.X specific code } You can use the defined constants: NSFoundationVersionNumber_iPhoneOS_2_0 NSFoundationVersionNumber_iPhoneOS_2_1 NSFoundationVersionNumber_iPhoneOS_2_2 NSFoundationVersionNumber_iPhoneOS_3_0 NSFoundationVersionNumber_iPhoneOS_3_1 NSFoundationVersionNumber_iPhoneOS_3_2 NSFoundationVersionNumber_iOS_4_0 NSFoundationVersionNumber_iOS_4_1 NSFoundationVersionNumber_iOS_4_2 NSFoundationVersionNumber_iOS_4_3 NSFoundationVersionNumber_iOS_5_0 NSFoundationVersionNumber_iOS_5_1 NSFoundationVersionNumber_iOS_6_0 NSFoundationVersionNumber_iOS_6_1 NSFoundationVersionNumber_iOS_7_0 NSFoundationVersionNumber_iOS_7_1 Also OS X has its own ones."
  },"/development/bdd/tdd/2014-11-20-bdd-mastermind-adding-calabash-and-creating-our-first-tests.html": {
    "title": "BDD - Mastermind : Adding calabash and creating our first tests",
    "keywords": "Development BDD TDD",
    "url": "/development/bdd/tdd/2014-11-20-bdd-mastermind-adding-calabash-and-creating-our-first-tests.html",
    "body": "This is the sixth post to create an application using BDD and TDD in iOS. If you missed the previous post, my recommendation is that you read it first here. If you just landed, better start on the first In this post is where we really start doing BDD, so get ready to enter to the new and exciting world of cucumber and behaviour driven development. Cucumber, What is it and How to use In previous post I’ve introduced the concept of cucumber, and in this post we are going to start with it. But first I’d like to give you a brief introduction about cucumber and what is it. Cucumber is an set of tools that allows us to write tests in “natural language” that are readable by the computer and tell it what to test and how to test. Notice that I’ve written “natural language” between quotes and in italics. That is because we should make a couple precissions here. First, the language is natural because it can be read as a natural language written story, but is not so natural in the sense that we can’t write it as it comes, but we have to follow some conventions that describe the gherkin syntax. Second, the test, as said before, are not going to work out of the box. Eventhough there are some steps that work with no additional effort, most of the steps will need a definition from your side. You could say - “what’s the point in writting the tests if we have to do another development job behind?” Well, the advantage you get from this is the ability to have clearer tests that can be mantained with lot less effort and that can be written, read and maintained by third party and non technical people. Back to school, let’s learn some syntax A good definition of what is gerkhin is in The Cucumber Book: Behaviour-Driven Development for Testes and Developers, an excellent book that I highly recomend you to read if you want to be a “Cucumber Master”. “Gherkin gives us a lightweight structure for documenting examples of the behavior our stakeholders want, in a way that it can be easily understood both by the stakeholders and by Cucumber.” Let’s see an example: Feature: Board behaviour As a Player I want to see how the cells react to my taps as expected So I can begin playing Scenario: Initial situation Given I am on the Initial Screen Then a new game should be ready You can see this peace of code is written in a way anyone could understand, well, anyone who speaks english. What about a non english speaker stake holder? Well, gherkin syntax can be written in 40 different languages. You can see a list of available languages by running cucumber gem as ‘cucumber –i18n help’ and you’ll be listed all available languages. At this moment, this is what my system shows. | ar | Arabic | العربية | | bg | Bulgarian | български | | bm | Malay | Bahasa Melayu | | ca | Catalan | català | | cs | Czech | Česky | | cy-GB | Welsh | Cymraeg | | da | Danish | dansk | | de | German | Deutsch | | el | Greek | Ελληνικά | | en | English | English | | en-Scouse | Scouse | Scouse | | en-au | Australian | Australian | | en-lol | LOLCAT | LOLCAT | | en-old | Old English | Englisc | | en-pirate | Pirate | Pirate | | en-tx | Texan | Texan | | eo | Esperanto | Esperanto | | es | Spanish | español | | et | Estonian | eesti keel | | fa | Persian | فارسی | | fi | Finnish | suomi | | fr | French | français | | gl | Galician | galego | | he | Hebrew | עברית | | hi | Hindi | हिंदी | | hr | Croatian | hrvatski | | hu | Hungarian | magyar | | id | Indonesian | Bahasa Indonesia | | is | Icelandic | Íslenska | | it | Italian | italiano | | ja | Japanese | 日本語 | | kn | Kannada | ಕನ್ನಡ | | ko | Korean | 한국어 | | lt | Lithuanian | lietuvių kalba | | lu | Luxemburgish | Lëtzebuergesch | | lv | Latvian | latviešu | | nl | Dutch | Nederlands | | no | Norwegian | norsk | | pa | Panjabi | ਪੰਜਾਬੀ | | pl | Polish | polski | | pt | Portuguese | português | | ro | Romanian | română | | ru | Russian | русский | | sk | Slovak | Slovensky | | sr-Cyrl | Serbian | Српски | | sr-Latn | Serbian (Latin) | Srpski (Latinica) | | sv | Swedish | Svenska | | th | Thai | ไทย | | tl | Telugu | తెలుగు | | tr | Turkish | Türkçe | | tt | Tatar | Татарча | | uk | Ukrainian | Українська | | uz | Uzbek | Узбекча | | vi | Vietnamese | Tiếng Việt | | zh-CN | Chinese simplified | 简体中文 | | zh-TW | Chinese traditional | 繁體中文 | So we could write the same peace of code we wrote before as. Característica: Comportamiento del Tablero Como jugador Quiero saber como reaccionan las celdas a mis pulsaciones tal como esper y así poder empezar a jugar Escenario: Situación inicial Dado que estoy en la pantalla inicial Entonces un nuevo juego debería estar listo And cucumber should be able to proceed the same way as when it was written in english. Of course the steps definitions won’t be called the same or will do any translation, but we can map them. Gherkin is basically a set of keywords organised in a certain way and followed by sentences that might or might not contain parameters and have to be defined as steps. The keywords used by gherkin are: First level Feature Background Scenario Second level Given When Then And But * Scenario Outline Examples First level keywords are used to separate different tests and group them, while the second level ones are to define each step or provide data to test on. I won’t go deeper on this as it is not the purpose of this port serie. As I commented before, if you really want to get more information go and buy the book The Cucumber Book: Behaviour-Driven Development for Testes and Developers, it’s at the high level Pragmatic Programmers always offer. Talk is cheap. Show me the code It all looks very nice, but, does it work? And how does that work? Well, let’s start by writting our first feature. If you remember a previous post in this series called BDD - Mastermind : Internal Design, I defined there the acceptance criterias the way a stakeholder would define them ( more or less, that’s my humble contribution ). Let’s bring it back to write a couple of them in gherkin. The screen should contain nine rows and five columns. The left most column has to be gray. The other five columns has to be white. When I first open the app, a new game should be ready. When a new game starts, the screen should contain no colors and no results. As you can imagine there are many ways to write those acceptance criterias in gherkin. The one I choosed is the following one. Scenario: Initial situation Given I am on the Initial Screen Then a new game should be ready As you might deduct, the step “Given I am on the Initial Screen” includes The screen should contain nine rows and five columns. The left most column has to be gray. The other five columns has to be white. There are, at least, two ways we can do it. Creating one step for each condition and then putting them all together in a single step called “Given I am on the Initial Screen” or creating all steps into the “Given I am on the Initial Screen”. I decided to go this second way, but it would be a good practice if you try to do it the other way and see how it works the same way or even better. So let’s dive into the definition of the steps. First of all, go to your project folder, be sure you are in the same folder as your .xcproject and then run $ gem install calabash-cucumber $ calabash-ios setup Checking if Xcode is running... When it is finished, open the new created .xcworkspace file and build the new target you have ending in -cal . You need to do it because cucumber needs a binary to run the tests on, otherwise you are going to start having complains from cucumber. In the project folder you’ll see a new folder called features, that’s where all cucumber magic lives. When you open the .feature file and replace the default feature for your new feature and you run cucumber, this is what you are going to see: ╰─$ DEVICE_TARGET='iPhone 6 (8.1 Simulator)' cucumber Feature: Board behaviour As a Player I want to see how the cells react to my taps as expected So I can begin playing Scenario: Initial situation # features/start.feature:6 Given I am on the Initial Screen # features/start.feature:7 Then a new game should be ready # features/start.feature:8 1 scenario (1 undefined) 2 steps (2 undefined) 0m15.800s You can implement step definitions for undefined steps with these snippets: Given(/^I am on the Initial Screen$/) do pending # express the regexp above with the code you wish you had end Then(/^a new game should be ready$/) do pending # express the regexp above with the code you wish you had end Note that the command used to run the test ‘DEVICE_TARGET=’iPhone 6 (8.1 Simulator)’ cucumber’. Please take a look at calabash documentation for more options. You can see how cucumber helps us. You can implement step definitions for undefined steps with these snippets: Given(/^I am on the Initial Screen$/) do pending # express the regexp above with the code you wish you had end Then(/^a new game should be ready$/) do pending # express the regexp above with the code you wish you had end Those are the steps you need to implement inside your features/step_definitions/mastermind_steps.rb file. Let’s take a look on how I’ve defined them. Given /^I am on the Initial Screen$/ do # The screen should contain nine rows and five columns rows = query(\"view {accessibilityLabel BEGINSWITH 'Combination Row'}\") fail(\"The screen should contain nine rows\") if rows.count != 9 # Following the mock, those rows have to be as wide as the screen window = query(\"window\") rows.each do |row| if row[\"frame\"][\"width\"] != window.first[\"frame\"][\"width\"] fail(\"All rows have to be as wide as the screen\") end end # Following the mock, the rows have distributed along the screen lastFloor = 0 rows.each do |row| if row[\"frame\"][\"y\"] != lastFloor fail(\"Each row has to be after the previous one, expecting #{lastFloor}, #{row[\"frame\"][\"y\"]} found\") end fail(\"All rows should be higher than zero\") if row[\"frame\"][\"height\"] == 0 lastFloor = row[\"frame\"][\"y\"] + row[\"frame\"][\"height\"] end # All rows are combination rows.each do |row| fail(\"All rows must be combination rows but #{row[\"class\"]} was found\") if row[\"class\"] != \"MMCombinationRow\" end sleep(STEP_PAUSE) end Then(/^a new game should be ready$/) do rows = query(\"view {accessibilityLabel BEGINSWITH 'Combination Row'}\") rows.each do |row| combination = row[\"label\"][18..23] fail(\"All rows combinations must be empty but #{combination} was found\") if combination != \"' '\" end end To match one buy one the acceptance criterias with the steps let’s split it. The screen should contain nine rows and five columns. # The screen should contain nine rows and five columns rows = query(\"view {accessibilityLabel BEGINSWITH 'Combination Row'}\") fail(\"The screen should contain nine rows\") if rows.count != 9 Previoulsy to this step, you can find a new class in the code called MMCombinationRow that has been created with TDD and ensures containing five cells, one result cell and four color cells. So what’s missing here is the number of rows. Another way to implement this check is: # The screen should contain nine rows and five columns rows = query(\"MMCombinationRow\") fail(\"The screen should contain nine rows\") if rows.count != 9 Go and implement the rest and see how it fails and what have you got to change to make it pass and then go and run the unit tests to ensure you didn’t break anything. If all goes fine, just making a git checkout of Step 7 and you should see something like this: Remember you can find the code of this post in this commit, Step 8. If you like it, please share! Thank you for reading me."
  },"/development/bdd/tdd/2014-11-10-bdd-mastermind-view-preparation.html": {
    "title": "BDD - Mastermind : View preparation",
    "keywords": "Development BDD TDD",
    "url": "/development/bdd/tdd/2014-11-10-bdd-mastermind-view-preparation.html",
    "body": "This is the fifth post to create an application using BDD and TDD in iOS. If you missed the previous post, my recommendation is that you read it first here. In the previous post I went through a way to test the visible result of the custom view in a very intuitive way. It was just an exercise to test how, in a simple way, we could have a complete test of how we expect our view looks like. The truth is that this is a feeble method as it depends on an image that might or might not be 100% achievable by the tools we can make use of. The purpose of the previous post was to introduce the technique we are going to use in this post. We are going to go through a technique that allows us to test the final behavior in a more secure and maintainable way. You can find the code corresponding to this post in this commit. Go and get it! The result cells The second element we have on the screen is the results cell. If you remember from the first post of the series, we defined three areas to consider. Area number three is a special kind of view that provides different visual aspects depending on the result we are providing. The rules are described in the second post of the series BDD - Mastermind : Internal design, but we need add a few more “conditions” to have a really robust view that does what we want it to do. First - We are only accepting two different symbols, no matter which symbols but just two different. Second - If the first symbol is a space, then it is considered there are no symbols of the first type and all the symbols are considered second kind. Third - As there is no specification, the circles will try to fill as much space as possible. One symbol will end in a single big circle. With this in mind we have enough information to start creating the tests to implement the result cell. Test and implementation A very common practice is to create helper methods to simplify the test and provide more clarity. In this case we need to create a combination generator, so I implement this random combination generators. // Helper Methods - (NSString *)generateRandomCharString { // Available symbols NSString *symbols = @\"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789\"; // Pick a random index to extract two symbols int symbolIndex = arc4random_uniform((int)symbols.length-1); // Obtain the two random symbols NSString *symbol = [symbols substringWithRange:NSMakeRange(symbolIndex, 1)]; // Obtain random number of each symbols int length = arc4random_uniform(10); NSMutableString *resultString = [NSMutableString stringWithString:@\"\"]; for (int n=0; n&lt;length; n++) [resultString appendString:symbol]; return [resultString copy]; } - (NSString *)generateRandomResult { NSMutableString *resultString = [[self generateRandomCharString] mutableCopy]; return [[resultString stringByAppendingString:[self generateRandomCharString]] copy]; } - (NSData *)dataForCellPNGRepresentationForView:(UIView *)view { UIGraphicsBeginImageContext(view.bounds.size); [view.layer renderInContext:UIGraphicsGetCurrentContext()]; UIImage* image1 = UIGraphicsGetImageFromCurrentImageContext(); UIGraphicsEndImageContext(); return UIImagePNGRepresentation(image1); } generateRandomCharString - Is used to generate a string of random lenght of a random symbol. As you can see I previously have defined the array of valid symbols which contain no space. A good practice would be to add a test to check that any symbol placed is included in the set of valid symbols. generateRandomResult - Is the method used to create a combination of two symbols. dataForCellPNGRepresentationForView - Is the method used to obtain a png representation of the view. That is the way we can compare two views at visual level. Now that we have all we need, let’s write some tests. I won’t go though each test as they are trivial, just list them. Test that on init the background is transparent. Test that on init the combination value is empty. Test that when the combination changes bezier path changes. Test that when the combination is empty bezier paths contains zero circles. Test that when the combination changes bezier paths contains the same number of circles as the length of the combination. Test that when the combination has more than two different symbols only first two are stored. Test that when the combination changes bezier paths contains only bezier paths; The final method for testing the visual result As I commented before, testing against images has some important limitations like depending on the device implementation, small changes makes the test fail, etc … So, which is the best way to do it? Well nothing better than comparing a view with another view. That way we can be sure there is no difference and we can update easily the implementation. To do it, you just need to create a view that looks like what you expect your view to look like. You might think, that is duplicating the effort. Well, create a dummy view that just does one thing is not duplicating the effort, is prototyping what you expect to obtain and also lets you define some rules that you might translate to your view. Let’s take a look at the dummy view I’ve implemented and you’ll understand better what I mean. // Dummy view to draw the image we expect @interface DummyView : UIView @property (nonatomic, strong) NSString *combination; @property (nonatomic, strong) UIColor *color; @end @implementation DummyView - (id)initWithFrame:(CGRect)frame combination:(NSString *)combination color:(UIColor *)color { self = [super initWithFrame:frame]; if (self) { self.combination = combination; self.color = color; self.backgroundColor = [UIColor clearColor]; } return self; } - (void)drawRect:(CGRect)rect { // Obtain first char unichar leftchar = [self.combination characterAtIndex:0]; NSString *combination = [self.combination stringByReplacingOccurrencesOfString:@\" \" withString:@\"\"]; // Obtain rectangle ration float K = rect.size.height/rect.size.width; // Obtain number of items long N = combination.length; // Obtain grid sizes float verItems = ceil(sqrtf(K*N)); float horItems = ceil(sqrtf(N/K)); // Items horizontally float gridHeigh = rect.size.height / verItems; float gridWidth = rect.size.width / horItems; // Draw circles [self.color setFill]; [self.color setStroke]; UIBezierPath *bezPath; int currentElement; for (int y = 0; y&lt;verItems; y++) { for (int x = 0; x&lt;horItems; x++) { currentElement = (horItems*y)+x ; if (currentElement &gt;= N) { break; } bezPath = [UIBezierPath bezierPathWithOvalInRect:CGRectMake(x*gridWidth, y*gridHeigh, gridWidth, gridHeigh)]; if ([combination characterAtIndex:currentElement] == leftchar) { [bezPath fill]; } else { [bezPath stroke]; } } } } @end This is the final implementation of the view, but usually it will grow with your development. Adding new features that you expect to find in your view. And more important, will protect you from changing what you expect to see if you make any change in your code in the future. With that in mind, the tests become a lot more clear. - (void)testIfNewResultHasOnlyOneSymbolByDefaultAreFirstSymbol { resultCell.result = [self generateRandomCharString]; resultCell.frame = CGRectMake(0, 0, arc4random_uniform(300), arc4random_uniform(300)); DummyView *dummyV = [[DummyView alloc] initWithFrame:resultCell.frame combination:resultCell.result color:resultCell.color]; NSData *expectedImage = [self dataForCellPNGRepresentationForView:dummyV]; NSData *obtainedImage = [self dataForCellPNGRepresentationForView:resultCell]; XCTAssertEqualObjects(expectedImage, obtainedImage); } Create our view. Create a dummy view with the same parameters. Extract the representing images. Check both match. Take a look at the rest of the test, I think they are pretty clear, but if you believe there is something you can’t see, just send me an email or leave me a comment. And with this post I finish with the TDD by now and we can start with the BDD. Please, leave me comments, share and like if you can! See you in the next post."
  },"/development/bdd/tdd/2014-10-21-bdd-mastermind-view-preparation-to-make-the-ui-testable.html": {
    "title": "BDD - Mastermind : View preparation to make the UI testable",
    "keywords": "Development BDD TDD",
    "url": "/development/bdd/tdd/2014-10-21-bdd-mastermind-view-preparation-to-make-the-ui-testable.html",
    "body": "This is the fourth post to create an application using BDD and TDD in iOS. If you missed the previous post, my recommendation is that you read it first here. If you thought we were going to jump straight to BDD I’m afraid you’ll have to wait a little more. To understand it, first of all I’m going to explain which is the framework I decided to use to BDD and how does it work. With all that info you’ll understand why we need to prepare the things to be able to BDD. You can find the code corresponding to this post in this commit. Go and get it! Calabash AUTOMATED ACCEPTANCE TESTING FOR MOBILE APPS If you go to calabash web site you’ll find this definition. Calabash enables you to write and execute automated acceptance tests of mobile apps. Calabash is cross-platform, supporting Android and iOS native apps. It is open source and free, and has a company, Xamarin, backing and developing it. The reasons I decided to go with calabash after some investigation and research are diverse. First of all was the ease of integrating it in your projects. Opposite to other platforms it is just a question of a few sentences to be able to integrate it. Second, it works with cucumber. I really love cucumber as a way to interface with non technical people and be able to understand the same things and write acceptance criterias that we both understand and agree, and more important, we can convert them in tests. When you are done with this post, never before ;), you can go to github calabash iOS repository and read how to install the gem and integrate it in your projects so you are able to follow the steps of this series of posts while you build your own, secure and testable app. What’s more important to understand in this post is that calabash works with the accessibility labels to inspect and perform tasks on the simulator and the device. That’s the reason why we can’t go straight to the tests when we are going to create an app that contains a bunch of custom views and we need to see if that view is red, blue, green or yellow for example. Sadly this is something we can’t get out of the box by now. But the good news are that we can create a view that is testable in that way. Creating Testable Views - TDD to the rescue First thing we need to do is to convert what is a view perception into an accessible label. How are we going to do it? Keep reading and you’ll know how. As usual we’ll start by creating a test file to test what I decided to call MMCell. The strategy used to create a view that behaves as we want it to behave visually when we can’t test that it really happens is to break it in to parts. One is tested with TDD and ensures that when setting properties on a view the visual changes happens as we expect. The other part is that those visual changes are expressed in a simple way in the accessibility label. To do it we’ll use two properties. bezierPath : This is a readonly property that will reflect the shape that is going to be drawn in the view. This we can verify what is being drawn in the view. color : This is a property to allow the app set the color of the circle that’s going to be shown in the view. To better understand how we are going to make it, let’s take a look at the first test: - (void)testWhenSizeChangesPathSizeChanges { int width = arc4random_uniform(200); int height = arc4random_uniform(200); cell.frame = CGRectMake(0, 0, width, height); UIBezierPath *expectedBezier = [UIBezierPath bezierPathWithOvalInRect:CGRectMake(0, 0, width, height)]; XCTAssertTrue(CGPathEqualToPath([expectedBezier CGPath], [cell.bezierPath CGPath]), @\"Bezier Path does not match expected shape\"); } The test is very simple. We get a random height and a random width, both between 0 and 200, and check that when we set the frame of the view the path generated matches what we expect. This doesn’t guarantees that this is what is going to be drawn. To do it we need to go one step forward. - (void)testFillIsCalledOnBezierPathWhenDrawRectIsCalled { id bezierMock = OCMPartialMock(cell.bezierPath); OCMStub([bezierMock fill]).andForwardToRealObject; [cell drawRect:cell.bounds]; OCMVerify([bezierMock fill]); } This test what basically does is to check if, when drawRect is called also fill is called on bezierPath object. To do it I use one of the best friends you can have when TDDing, Mocks. Sadly this is something that is not natively implemented in XCTest, so we need to find third party developments to use it. There are different libraries that implement mocks for iOS. In this case I decided to choose OCMock which is a very well known and tested libraries, but OCMockito is also an excellent option. Basically a mock is an object that “replaces” totally or partially the object you are trying to test or an object you want to behave in a certain way so you check what happens or make things happen in a controlled environment. I know this sounds a little weird, so if you want me to write a full post about Mocking in iOS, please ask me for it in the comments or twitter and I’ll prepare it. This is a good moment to introduce another player that will join you projects very often. CocoaPods If you are already familiar with CocoaPods you can jump straight to Testing what it looks like. In CocoaPods Web Site they define themselves as CocoaPods is the dependency manager for Objective-C projects. It has thousands of libraries and can help you scale your projects elegantly. I would add to it that they do it in an awesome and very clean way. Until I discovered CocoaPods I needed to include, organize and maintain third party developments manually. CocoaPods let’s you do it all in a very clean and isolated way so you can start using the those libraries in less than five minutes. Let’s see how to do it in our case. You have a very complete instruction set in CocoaPods Web Site but basically is three steps. Install the gem with sudo gem install cocoapods. Create a file named “Podfile” in the same folder you have your .xcodeproj file and include the information you need in it. Run pod install from the terminal in that folder. After those three simple steps you’ll have a new .xcworkspace file with two projects in it, one your project and the other the project to build the pods library. From this point you just need to include the pod header you need in each file you need it. In this case by now I just need to include &lt;OCMock/OCMock.h&gt; in the Test File. The content of this first version of the Podfile is the following. source 'https://github.com/CocoaPods/Specs.git' platform :ios, '8.0' xcodeproj 'MasterMind' target :MasterMindTests do pod 'OCMock', '~&gt; 3.1.1' end Note that I added the pod only to the Test target, that means this pod won’t be available in release target, which is what we want. Testing what it looks like We need to do the same we’ve done with bezierPath with color so we ensure that “setFill” is called on color property when “drawRect” is called on the view. This test will make it. - (void)testSetFillIsCalledOnColorWhenDrawRectIsCalled { id colorMock = OCMPartialMock(cell.color); OCMStub([colorMock setFill]).andForwardToRealObject; [cell drawRect:cell.bounds]; OCMVerify([colorMock setFill]); } At this point we know the properties are set, updated on changes, called SetNeedsDiplay to request redraw ( look at the code ) and we are sure that they are called when drawRect is called, but how can we ensure the last result is what we expect to be. There are many ways to do it so here is what I suggest in this case. Remember I’m not trying to be exhaustive in this series but create an exercise to show you all the possibilities we have so far to test an app. The best way to let the test see if the final result is what we want is compare it with an image that represents what we want, so that’s what we are going to do. In this case I took some images that represents what the view should look like in different circumstances. Those are: Now, how to check the view against the image? This is the test. - (void)testViewMatchesExpectedImage { cell.color = [UIColor redColor]; cell.frame = CGRectMake(0, 0, 200, 200); NSString* fileImageName = [[NSBundle bundleForClass:[self class]] pathForResource:\"testImageRed\" ofType:@\"png\"]; UIImage *fileImageObj = [[UIImage alloc] initWithContentsOfFile:fileImageName]; UIImage *expectedImage = UIImagePNGRepresentation(fileImageObj); UIGraphicsBeginImageContext(cell.bounds.size); [cell.layer renderInContext:UIGraphicsGetCurrentContext()]; UIImage* image1 = UIGraphicsGetImageFromCurrentImageContext(); UIGraphicsEndImageContext(); UIImage *viewImage= UIImagePNGRepresentation(image1); XCTAssertEqualObjects(viewImage, expectedImage, @\"View should look like the image\"); } The base is that we obtain the NSData representation of both images and we compare them, that will tell us if they match or doesn’t. And that’s all for now. Now we have testable view cells. We need testable result cells and then we can start with BDD. Remember you can find the code of this post in this commit. If you like it, please share! If you believe there is some part that needs more detail or want to suggest a new post like with Mocking, just send me your thoughts. Thank you for reading me. In the next post BDD - Mastermind : View Preparation we’ll find a more robust and maintainable way to create tests for the visual aspect."
  },"/development/bdd/tdd/2014-09-29-bdd-mastermind-tdd-in-the-model.html": {
    "title": "BDD - Mastermind : TDD in the model",
    "keywords": "Development BDD TDD",
    "url": "/development/bdd/tdd/2014-09-29-bdd-mastermind-tdd-in-the-model.html",
    "body": "This is the third post to create an application using BDD and TDD in iOS. If you missed the previous post, my recommendation is that you read it first here. It’s time to get your hands dirty. To make it really easy I’ve decided to tag each relevant commit with step numbers so you can follow step by step the process. I recommend you to code your own version, but if at some point you are lost, just checkout the step where you got lost and we’ll be synchronized again. First thing to do is create your project and have it ready to run. You can create a new project or checkout this commit or just checkout from terminal by : git clone git@github.com:guillemf/Mastermind-BDD.git git tag -l git checkout tags/Step_1. As you might now the process of TDD is basically writing a test, seeing how it fails, implement the solution and run again the test until it passes. I’m not going to go deep in what is TDD as there are many webs that explain very well how to do TDD like Quality Coding specially the screencast series starting with Intro to Objectve-C TDD. So, assuming you know what is TDD and how to do it, let’s start our process. What I do is take each requirement and try to dissect it in all the possible unitary tests I can do covering all possibilities. So let’s start on the first one. Every time we start a new game, the model has to create a new secret combination. The first test to write is to be sure that right from the beginning there is something in combination. I write my first test and, following the method, I get my first error. So I need to fix that situation, first by implementing MMModel class. With this implementation @interface MMModel : NSObject @property (nonatomic, strong) NSString *combination; @end @implementation MMModel - (id)init{ self = [super init]; if (self) { self.combination = @\"\"; } return self; } @end The tests passes, things seem to go in the right way. Let’s face the second test. As it says every time we start a new game, a new combination, the next test seems obvious that it has to be something like: - (void)testModelOnStartShouldGenerateANewCombination { MMModel *model = [[MMModel alloc] init]; NSString *originalCombination = model.combination; [model start]; XCTAssertNotEqual(originalCombination, model.combination, @\"After start the combination has to be different from the previous one\"); } But that only covers one iteration, and unit tests has to be independent on the contexts, that mean a random number of times, so let’s introduce a random number to repeat starts. - (void)testModelOnStartShouldGenerateANewCombination { MMModel *model = [[MMModel alloc] init]; int lowerBound = 1; int upperBound = 5; int rndValue = lowerBound + arc4random() % (upperBound - lowerBound); for (int n= 1; n&lt;=rndValue; n++) { NSString *originalCombination = model.combination; [model start]; XCTAssertNotEqual(originalCombination, model.combination, @\"After start the combination has to be different from the previous one\"); } } And this implementation - (void)start { self.combination = [NSString stringWithFormat:@\"%d\", arc4random()]; } Makes the test pass. Yes, you might think “Hey, that’s a trick. This is not a valid combination!!” and you’d be right, but don’t forget TDD says “Write the minimum amount of code that makes the test pass”, and that’s what we are doing. Later on we’ll find that we need to change this implementation to pass other tests, but we’ll be sure we are not breaking the rules with the following and more complex tests we need to pass. It’s time for some refactoring and we’ll move the declaration of model to the setup method. As we need a new combination from the start, we’ll also move a call to start in the model inside the creation. We run the tests by Cmd+U and see all still works. Next requirement is : The secret combination is four numbers long. So the tests are : - (void)testModelSecretCombinationShouldContainFourNumbers { XCTAssertEqual(model.combination.length, 4ul, @\"Secrect combination length should be four\"); } - (void)testModelSecretCombinationIsNumeric { NSCharacterSet* nonNumbers = [[NSCharacterSet decimalDigitCharacterSet] invertedSet]; NSRange r = [model.combination rangeOfCharacterFromSet: nonNumbers]; XCTAssertEqual(r.location, NSNotFound, @\"All digits should be numeric\"); } And here we have our first need of re-coding a part of the source to be able to pass those two tests. Try to do it by yourself and if you can’t see how to do it, you can go and checkout this commit. With the next requirement, things start becoming complicated and won’t be so easy in terms of coding. The numbers in the combination are between 1 and 4. Let’s write the test to fail. - (void)testModelSecretCombinationAllDigitsAreBetween1and4 { NSCharacterSet* non1234 = [[NSCharacterSet characterSetWithCharactersInString:@\"1234\"] invertedSet]; NSRange r = [model.combination rangeOfCharacterFromSet: non1234]; XCTAssertEqual(r.location, NSNotFound, @\"All digits should be between 1 and 4\"); } Again all the challenge is inside start method in MMModel.m. It is a good practice to try to implement it by yourself. Once you are done, checkout Step 3 and you can compare your solution to mine and see how beautiful it is to see there are many ways to find a solution for the same problem. And remember to write the less possible code to pass the tests. To not make this post eternal, I will just comment next requirement: The numbers in the combination can be repeated. In this case we can’t write a test, at least in an easy way, about how to allow something. If opposite to this requirement it would be “The numbers in the combination can be repeated” it would be easy to traverse the digits and ensure there is no repetition, but as long as this is not a restriction, I won’t write a test for it. As usual, you can have a different opinion and write a test to verify it, I encourage you to do it and paste a comment explaining why you took that decision. You’ll find the full code for this post in Step 4. In the next post BDD - Mastermind : Preparation to make the UI Testable we’ll start preparing the views to implement it with BDD. If you like it, please share! And leave me a comment if you have some time, I’d love to know this is helping someone ;)"
  },"/development/bdd/2014-09-25-bdd-mastermind-internal-design.html": {
    "title": "BDD - Mastermind : Internal design",
    "keywords": "Development BDD",
    "url": "/development/bdd/2014-09-25-bdd-mastermind-internal-design.html",
    "body": "This is the second post to create an application using BDD and TDD in iOS. If you missed the first post, my recommendation is that you read it first here. In this post we are going to walk through the process of designing how we are going to architecture it internally and start writing down the first specifications that later on will become tests. I decided to structure it the way a “non technical” person would describe what she wants and then move it to the world of Unit Testing and Acceptance Tests. First TDD Let’s begin by revisiting the most important design pattern used in iOS Development, Model - View - Controller. The internal design we are going to implement follows the classic schema. The first decision to make here is where to put the logic. I’ve seen many designs that include the logic in the controller and leave the model just as a mere repository. My understanding is that the controller should act as the “where to take this” and “where to put that”, not as the container of “what happens when y put this” or “what should I obtain when I deliver this”. So, here is the first decision, the logic of the game will live in the model. Let’s write some requirements the model has to follow. Every time we start a new game, the model has to create a new secret combination. The secret combination is four numbers long. The numbers in the combination are between 1 and 4. The numbers in the combination can be repeated. Every time we start a new game, the number of attempts has to be zero. The maximum number of attempts is nine. Only combinations of four numbers are accepted. The combinations can contain duplicated numbers. The numbers accepted in the combinations are between 1 and 4. Every time a new combination is inserted a new result will be generated. The result of a new combination inserted is a one letter “A” for each number that is in the secret combination in the right position and a letter “B” for each number that is in the combination but is not in the right position. If the result is “AAAA” no new combination will be accepted. If the number of attempts is nine and the last result is not “AAAA” no new combination will be accepted. Its has to be possible to obtain the history of the game being played at any moment, providing the ordered sequence of pairs combination-result. These are the requirements to follow. As you can see I’ve simplified the mastermind rules in order to make this exercise more understandable. We are not trying to create the final app but to understand what are we doing. Now BDD Now that we have the model specified, let’s go for the behavior we want for the app. These requirements are written in natural language and then we’ll rewrite later on in gherkin sintax, which is the syntax used to describe the behavior that cucumber understands. As you will see, it is a very understandable syntax. Try to show the final result of the scenarios to a non technical person and see how easy she can understand and validate them, that’s the great advantage I find in this, it’s a bridge between devs and PO that both can understand and agree to a behavior with no interpretations and confusions. Those could be the requirements. Note that we have to go to the very basic behavior to be sure nothing is left to no specification. If something is not explicitly defined, that means than nothing happens in that case. The screen should contain nine rows and five columns. The left most column has to be gray. The other five columns has to be white. When I first open the app, a new game should be ready. When a new game starts, the screen should contain no colors and no results. Up to this point we have initial conditions. Let’s define the behavior to play. When I tap on a white cell a red circle should appear. When I tap on a red circle cell, a yellow circle should appear. When I tap on a yellow circle, a green circle should appear. When I tap on a green circle, a blue circle should appear. When I tap on a blue circle, a red circle should appear. When I swipe my finger from left to right the combination should be validated. When a combination has been validated, no tap on that row will react. When a row has no validated combination above on tap on its cells should react. When the number of validated combinations is zero the first row will behave as if there was a validated row above it. The third group of specifications will be the behavior of the results and the reset of the game. If a combination is not validated the left most cell of the row will show no content. When a cell is validated the left most cell of the row will show the result of the combination. For each color of the combination that is in the right position the result cell will show a black circle. For each color of the combination that is not in the right position the result cell will show a white circle. If there is a result cell showing four black colors the board shouldn’t react to any gesture except for the game reset. If I swipe the board from left to right the current game should finish and a new game should start. And this is all. We have created the specifications for all the rules and behaviors of the game. Of course we can define a lot more and be more exhaustive. But this is a good beginning. In the next post BDD - Mastermind : TDD in the Model we’ll start implementing using TDD for the Model. If you like it, please share! And leave me a comment if you have some time, I’d love to know this is helping someone ;)"
  },"/development/extra/bdd/2014-08-20-bdd-from-the-idea-to-the-app-2.html": {
    "title": "BDD: From the idea to the App 2",
    "keywords": "Development Extra BDD",
    "url": "/development/extra/bdd/2014-08-20-bdd-from-the-idea-to-the-app-2.html",
    "body": "It’s been almost two years since I wrote my post from the idea to the App, and that’s a long time. Since then many things changed and I’ve been working a lot on BDD and TDD. So I guess this is a great moment to start a new series of posts about how to do the full process. Last year I did a formation on iOS development. The final lessons consisted in creating a game, the Mastermind game. I think it is a good idea to use this example to build and app using TDD and BDD. Of course this process will not contain the full creation process with all details as it would take ages, even a book to do it, but I will include the headlines of the process with all the details and guides to complete the process, and of course with the code to do it. Let’s start with it. Introduction We want to create the classic mastermind game. For those that doesn’t know how top play Mastermind can take a look at wikipedia where the rules are very well explained. In order to make this easier, let’s simplify some rules. We’ll make a fix number of games to play, let’s say nine, the codemaker will always be the iPhone and finally, there will be no points distribution, if the codebreaker guesses the pattern of colors before ten games, wins, otherwise loses. Of course those restrictions can be released in the future, but for now, let’s do it this way. What do you need to start and App The first job to be done is far from the keyboard. We all want to start typing and working with the mac and seeing how it is starting to look like we expect to see it, but the truth is that The better you prepare it all, the best result you’ll get. So now let’s put our Product Owner hat on and let’s draw what we want. In this case, as we are going to create a game, we can start with the graphical part, because it will drive most of the subsequent user stories. Drawn on paper it could look like something like this. I like to draw my first version with a pen or pencil so I can make easy and fast corrections as many times as I want. Once I am happy with the result, I will be able to proceed with more sophisticated tools or even ask a graphical designer to make a nice version of what I have on my mind to look as nicer as possible. But remember, one step at a time and don’t try starting to build your house by the roof. The sketch contains all the information we need. It has a place to put the combinations. It has a place to show the result of the try. And it has enough space to repeat each try until the user gas the combination or consumes all the opportunities. Easy right? Well now you can say you have not only an idea but also what it should look like. Next step is start with the analysis of what we’ve just drawn. First task, Analise what have we got to work with First thing we can identify is that there are four different zones that we can identify. 1 - Left column is different from the rest. It will contain the results of the last combination we played. 2 - Four columns at the right of the first column. They will contain each of the combination we’ve tried in chronological order. 3 - Cell content with a special control that contains the result of the combination composed by the four colors at its right. 4 - Row contents with four cells, each with a color representing a combination. I know this analysis might seem too basic and simplistic, but believe me, simple analysis lead to simple and effective solutions and makes you not missing any part of your project. In fact engineering is that, dividing problems in smaller problems and those in more smaller until we are able to find a solution for each one and then reintegrate them in one big solution. And that’s all for this post. In the next post BDD - Mastermind : Internal Design we’ll start writing the requirements for the graphic part so we can be able to transform them into scenarios we can test in our continuous integration system. Please, don’t forget to share this post if you liked it."
  },"/productivity/o'reilly/video/2014-07-02-oreilly-media-videos.html": {
    "title": "O’Reilly Media Videos",
    "keywords": "Productivity O'Reilly Video",
    "url": "/productivity/o'reilly/video/2014-07-02-oreilly-media-videos.html",
    "body": "Mac OS X Productivity Tips for Developers I am a big fan of O’Reilly Media products because of their quality and the real value added that I usually get as a professional. In the past I acquired some of the videos like Mastering Git or Mastering Advanced Git , which I highly recommend if you are a Git user, and I found they are impressive easy to follow, immediate to apply and in return you get a huge increase of you expertise and so a good competitive advantage. Some time ago I discovered a new video from O’Reilly called Mac OS X Productivity Tips for Developers and I almost immediately wanted to buy it and start getting all that included tips and tricks to use them in my daily tasks as developer. I normally take advantage of the “Deal of the day” or “Deal of the week” at O’Reilly, and I though that this was going to be a good candidate to wait for. Today, I finally got the luck to be able to access to it thanks to O’Reilly, and I really believe that in return of their attitude it is fair to share my thoughts and opinions about this video that might encourage some of you to buy it. To do that my compromise is to post an opinion about each of the chapters or group of chapters you can find in the video, this first post is about first chapter. Keyboard Hacks This first video has been like opening a window and letting some fresh air come in. As you might know I am iOS Developer. I spend most of my day in front of my computer pressing the keys and looking at the monitor all time. Some time ago I had a tendinitis in my right hand I my doctor said it was because of an excessive use of the mouse. After that I bought a trackpad to try to alternate and so reduce the pain and the risk of another injury. In this video you’ll find some tricks to keep your fingers on the keyboard to do those kind of tasks you repeat hundreds of times every day and makes you use the mouse/trackpad with the subsequent lose of time and risk of stressing your wrist too much and end having a tendinitis. I really believe this is a good bunch of tips and tricks to incorporate to your daily routine. Let’s see what more has it inside to help me. Terminal Tips This chapter is focused on the terminal, that big unknown for many users, loved and hated in the same proportion, but needed at some point if you are or you are thinking about becoming a developer. The chapter starts talking about iTerm2 and how to use it, set it up and customize to your preferences, but beyond that you get a series of tips to be able to improve your productivity and avoid errors that will save your butt in more than one situation. At the end of the chapter the reveal a great ‘utility’ for your terminal that will make you love this video just for it and you’ll use for sure in your daily basis work, and not only that, they show you where to get more like them. Take a look at it, it’s worth it. File Formats The title of this video does not give you a clue about what’s inside. This chapter is all about mark up languages to write documents from README to complete books. To be fair I have never gone beyond Markdown and Multimarkdown, and in the past I had some problems when writing a book with those formats that lead me to choose visual editors that made me lose that plus in portability of the documents. Now, after seing the video, I’d choose another option that would have change things a lot. Again, and in the same line of the other chapters, it’s a great value video, don’t lose it. Source Control Assistants This video is about Git basically as they are great GIT professionals and have the videos I highly recommended in the previous posts, but opposite to what I was expecting to see, in this video they don’t focus on visual Git clients but in terminal utilities to, again, focus on productivity. They go though a couple utilities I didn’t even know that existed and show you those unvaluables tips focused to productivity. It is a great info if you work with Git and greater if you also use Github. Package Management Package Management is one of those thing you never pay attention to until the moment you really need them because you need that utility or that others and there is no other way to obtain them. I’ve been using package managers since meany years but, to be fair, I never had a good reason to use one or another. In this chapter you get information about a couple package managers and also some tips on how to use them and why. It is all focused form the perspective of the terminal usage as it is the rule since now and in a very understandable and wasy to follow way, it is another pearl in the course. Searching with Spotlight First of all I have to say that I am not a big fun of Spotlight. It looks to me nothing more that a textbox where to find items in the system, with an horrible and unusable list of results. To find and system items in a fast way I use launchbar, which I believe is a power and well designed tool. Once again, Mathew and Tim showed me how wrong I was, explaining very well that behind Spotlight there is a lot more power using a sort of query language, that lets you filter by the existing, created and automated metadata that lives inside our system items, and how to take advantage of it to make it work in our favor without, once again, taking your hands out of the keyboard. Viewing with Quicklook and Moving with Finder This review is about to short chapters. First one is about what to do with quicklook. As usual Mathew and Tim takes it one step beyond showing you which are the ‘mush have’ quicklook plugins and how to use them even without removing your hands from the keyboard. The second one is about the finder. I’ve complained many times about finder and all the functions I miss in it, but there is certainly a few tips you can use to make the job faster, easier and more effective. As usual they drive you through this topic in an easy and very understandable way. Saving to the cloud This time I was expecting to find something like “how to use iCloud” or a chapter based on how to use services like Dropbox or BOX, but instead of that, once again, surprise surprise, it’s not about that. This is productivity tips for developers, so let’s show you how to use the cloud in our benefit to store and share binaries, peaces of code or even social media content from the command line, all explained in a very nice way and providing all the information about where to find it, how to use it and where to get more info. I think I’m going to start twitting in a very different way from now, without moving my hands out of the keyboard. Web Service Helpers In this cruisade about keeping your hands far from the mouse and the trackpad, Matthew and Tim drives you into the world of the utilities to fetch and download information from the internet with commands. Here you can learn how to get information about the headers and bodys of the websites you need to work with from the terminal prompt. Also you can learn how to download and manipulate files or forward them and all at a few key presses from you, not the best one up to the moment but for sure one of the ones I’m going to use more frequently. Pasteboard Command Line I decided to put this chapter together with the previous one because of its shortness. This is about how to use the clipboard from the command line as the title says. You never know how useful it can be until you realize the big amount of situations where it becomes a productivity improvement, not only to copy and paste data, but also to use commands and create gists with no mouse interaction. Shell Tune-Ups In this chapter we are introduced to z-shell, an amazing and full of possibilities shell to work with. I have to say that I’ve been told in the past about this shell, but never had the oportunity to dive into it. The main reason to not try it was the poor information I founded. Here Tim and Mathew introduces you to “Oh My Zsh” which is an awesome and easy way to install, maintain and customize zsh. During the chapter you become less and less scared about moving to this other shell and see all the benefits, from moving from one folder to another, themimgs the shell or listing the options a subcommand has. Again we are in front of a master lesson by Tim Berglund and Mathew McCullogh. Display Control This is a small chapter about how to control the elements on the screen like windows organisation, windows switching and prevent from going to sleep. It’s not the most interesting one but yet provides a bunch of tips that are good to know in the same line of the rest of the videos."
  }}
